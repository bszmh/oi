在对于上述分治算法的分析中我们注意到，若记b[j]=max(a[i]+a[i+1]+..+a[j]),其中1<=i<=j,并且1<=j<=n。则所求的最大子段和为max b[j]，1<=j<=n。
由b[j]的定义可易知，当b[j-1]>0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。故b[j]的动态规划递归式为:
b[j]=max(b[j-1]+a[j],a[j])，1<=j<=n。
代码如下：
时间复杂度：O(N)


动态规划的基本原理这里不再赘述，主要讨论这个问题的建模过程和子问题结构.时刻记住一个前提，这里是连续的区间

令b[j]表示以位置 j 为终点的所有子区间中和最大的一个
子问题:如j为终点的最大子区间包含了位置j-1,则以j-1为终点的最大子区间必然包括在其中
如果b[j-1] >0, 那么显然b[j] = b[j-1] + a[j]，用之前最大的一个加上a[j]即可，因为a[j]必须包含
如果b[j-1]<=0,那么b[j] = a[j] ,因为既然最大，前面的负数必然不能使你更大
对于这种子问题结构和最优化问题的证明，可以参考算法导论上的“剪切法”，即如果不包括子问题的最优解，把你假设的解粘帖上去，会得出子问题的最优化矛盾.证明如下：

令a[x,y]表示a[x]+…+a[y] , y>=x
假设以j为终点的最大子区间 [s, j] 包含了j-1这个位置，以j-1为终点的最大子区间[ r, j-1]并不包含其中
即假设[r,j-1]不是[s,j]的子区间
存在s使得a[s, j-1]+a[j]为以j为终点的最大子段和,这里的 r != s 
由于[r, j -1]是最优解, 所以a[s,j-1]<a[r, j-1],所以a[s,j-1]+a[j]<a[r, j-1]+a[j]
与[s,j]为最优解矛盾.
